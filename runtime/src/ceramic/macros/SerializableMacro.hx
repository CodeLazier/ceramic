package ceramic.macros;

import haxe.macro.Context;
import haxe.macro.Expr;

using StringTools;

class SerializableMacro {

    macro static public function build():Array<Field> {
        var fields = Context.getBuildFields();
        var pos = Context.currentPos();

        // Check class fields
        var fieldsByName = new Map<String,Bool>();
        for (field in fields) {
            fieldsByName.set(field.name, true);
        }

        // Also check parent fields
        var parentHold = Context.getLocalClass().get().superClass;
        var parent = parentHold != null ? parentHold.t : null;
        while (parent != null) {

            for (field in parent.get().fields.get()) {
                fieldsByName.set(field.name, true);
            }

            parentHold = parent.get().superClass;
            parent = parentHold != null ? parentHold.t : null;
        }

#if (!display && !completion)
        // Gather default values
        var defaultValueFields = [];
        var prefixLen = 'unobserved'.length;
        var used = new Map<String,Bool>();
        for (field in fields) {

            switch (field.kind) {

                case FVar(t, e), FProp(_, _, t, e):

                    // Remove any prefix generated by other ceramic macros
                    var fieldName = field.name;
                    if (fieldName.startsWith('unobserved')) {
                        fieldName = fieldName.charAt(prefixLen).toLowerCase() + fieldName.substr(prefixLen + 1);
                    }

                    if (e != null && !used.exists(fieldName)) {
                        used.set(fieldName, true);

                        defaultValueFields.push({
                            pos: field.pos,
                            name: '_default_' + fieldName,
                            kind: FFun({
                                args: [],
                                ret: t,
                                expr: {
                                    expr: EReturn(e),
                                    pos: field.pos
                                }
                            }),
                            access: [APrivate],
                            doc: '',
                            meta: [{
                                name: ':noCompletion',
                                params: [],
                                pos: pos
                            }]
                        });
                    }


                default:
            }
        }
        fields = fields.concat(defaultValueFields);
#end

        if (!fieldsByName.exists('_serializeId')) {
            fields.push({
                pos: pos,
                name: '_serializeId',
                kind: FVar((macro :String), (macro ceramic.Utils.uniqueId())),
                access: [APublic],
                doc: '',
                meta: [{
                    name: ':noCompletion',
                    params: [],
                    pos: pos
                }]
            });
        }

        // Add serialize/deserialize events
        if (!fieldsByName.exists('emitSerialize')) {
            var eventField = {
                pos: pos,
                name: 'serialize',
                kind: FFun({
                    args: [],
                    ret: macro :Void,
                    expr: null
                }),
                access: [],
                doc: 'Event when this object gets serialized.',
                meta: []
            };
            EventsMacro.createEventFields(eventField, fields, fieldsByName);

            eventField = {
                pos: pos,
                name: 'deserialize',
                kind: FFun({
                    args: [],
                    ret: macro :Void,
                    expr: null
                }),
                access: [],
                doc: 'Event when this object gets deserialized.',
                meta: []
            };
            EventsMacro.createEventFields(eventField, fields, fieldsByName);
        }

        return fields;

    } //build

    static function hasSerializeMeta(field:Field):Bool {

        if (field.meta == null || field.meta.length == 0) return false;

        for (meta in field.meta) {
            if (meta.name == 'serialize') {
                return true;
            }
        }

        return false;

    } //hasSerializeMeta

} //SerializableMacro
